# **MSA 환경에서의 트랜잭션 처리 한계와 해결방안 (서비스 설계 문서)**

## **1. 개요**
### **📌 서비스 분리 배경**
서비스의 규모가 확장됨에 따라 기존 모놀리식(monolithic) 아키텍처에서 **MSA(Microservices Architecture)** 형태로 전환이 필요하다.  
각 도메인별로 배포 단위를 분리하면 **유연한 확장성(Scalability)과 독립적 배포(Deployment Independence)** 가 가능하지만, **트랜잭션 일관성 보장**이라는 새로운 문제가 발생한다.

### **📌 해결해야 할 핵심 문제**
1. 서비스 간 트랜잭션을 어떻게 보장할 것인가?
2. 트랜잭션을 고려한 서비스 분리 전략은 무엇인가?
3. 트랜잭션 방식(SAGA, 2PC, 이벤트 기반 트랜잭션) 중 어떤 방식을 선택할 것인가?
4. 데이터 일관성을 유지하면서 확장 가능한 아키텍처를 어떻게 설계할 것인가?
5. 장애 발생 시 트랜잭션을 어떻게 복구하고 일관성을 유지할 것인가?
6. 성능 모니터링 및 최적화 방안은 무엇인가?

---
## ** 분산 트랜잭션(Distributed Transaction) 개념**
### **📌 분산 트랜잭션이란?**
- **분산 트랜잭션(Distributed Transaction)** 은 **여러 개의 독립적인 서비스(데이터베이스, 메시지 브로커, API 등)가 연관된 트랜잭션을 하나의 논리적인 단위로 처리하는 방식을 의미한다.
- **MSA 환경에서는 하나의 비즈니스 로직이 여러 서비스에 걸쳐 실행**되기 때문에, **각 서비스의 데이터베이스에 저장된 상태를 일관되게 유지해야 하는 문제가 발생한다.

### **📌 기존 단일 트랜잭션과의 차이점**
| **항목** | **단일 트랜잭션 (Single Transaction)** | **분산 트랜잭션 (Distributed Transaction)** |
|----------|---------------------------------|---------------------------------|
| **처리 방식** | 하나의 RDBMS 내에서 실행됨 | 여러 개의 데이터베이스 또는 서비스에서 실행됨 |
| **ACID 보장 여부** | ✅ 완전 보장 | ❌ 완전 보장 어려움 |
| **트랜잭션 관리** | 단일 DBMS에서 트랜잭션을 관리 | 여러 서비스에 걸쳐 트랜잭션 관리 |
| **대표적인 해결 방법** | 로컬 트랜잭션, RDBMS의 Commit/Rollback | SAGA 패턴, 2PC, 이벤트 기반 처리 |

✅ **모놀리식 아키텍처에서는 하나의 DB 트랜잭션으로 ACID를 보장할 수 있지만, MSA에서는 분산된 서비스 간 데이터 일관성을 보장하는 것이 핵심 과제이다.**

--- 
## **2. 도메인별 서비스 분리 전략**
### **📌 기존 모놀리식 구조**
- 하나의 **단일 데이터베이스**에서 모든 서비스가 작동
- 트랜잭션은 **RDBMS의 ACID 트랜잭션을 통해 보장됨**
- 단점: **확장성 문제, 서비스 간 강한 결합, 배포 속도 저하**

### **📌 MSA 환경에서의 도메인 분리**
- **주문(Order) 서비스**
- **결제(Payment) 서비스**
- **상품(Product) 서비스**
- **고객(User) 서비스**

각 서비스는 **독립적인 데이터베이스를 운영**하며, **서비스 간 API 통신** 또는 **비동기 메시징(Kafka, RabbitMQ)** 을 사용하여 데이터를 주고받는다.

✅ **장점**: 유연한 확장성, 독립적 배포 가능  
❌ **단점**: 분산된 데이터로 인해 트랜잭션 관리가 어려움

---

## **3. 트랜잭션이 필요한 주요 비즈니스 로직**
### **📌 트랜잭션이 필요한 흐름**
1. **주문 생성 (`Order Created`)**
    - 고객이 주문을 생성하면 **주문 서비스(Order Service)** 에서 `order` 데이터를 저장
2. **결제 승인 (`Payment Approved`)**
    - 결제 서비스(Payment Service)에서 결제 승인 후 주문 상태 업데이트
✅ **문제점**: 하나라도 실패하면 전체 프로세스를 롤백해야 하지만, **MSA 환경에서는 기존 RDBMS 트랜잭션처럼 Rollback이 불가능함**

---

## **4. 트랜잭션 해결 방안**
### **✅ 1) SAGA 패턴을 활용한 트랜잭션 관리**
- **SAGA 패턴 개요**
    - 하나의 트랜잭션을 **여러 개의 로컬 트랜잭션**으로 분할하여 관리
    - 실패 시 **보상 트랜잭션(Compensation Transaction)** 을 실행하여 롤백

- **SAGA 방식 비교**
  | 방식 | 설명 | 장점 | 단점 |
  |------|------|------|------|
  | **Choreography** | 서비스 간 이벤트를 주고받으며 트랜잭션 진행 | 서비스 간 결합도 낮음 | 이벤트 흐름이 복잡 |
  | **Orchestration** | 중앙 트랜잭션 관리자가 트랜잭션을 제어 | 흐름이 명확 | 단일 장애점 발생 가능 |

✅ **적용 사례**: **주문-결제-배송 서비스**

---

### **✅ 2) 2PC (Two-Phase Commit) 적용**
- **트랜잭션 매니저**가 `Prepare → Commit` 2단계로 트랜잭션을 관리
- 강한 데이터 일관성을 보장하지만, **Coordinator 장애 발생 시 전체 트랜잭션 실패 가능**

✅ **적용 사례**: **은행 이체, 금융 거래**

---

### **✅ 3) 이벤트 기반 트랜잭션 (Eventual Consistency)**
- **Kafka, RabbitMQ 같은 메시지 큐를 활용하여 비동기 이벤트 처리**
- **최종적 일관성(Eventual Consistency) 보장**

✅ **적용 사례**: **알림 서비스, 로그 저장, 비즈니스 이벤트 처리**

---

## **5. 트랜잭션 장애 대응 방안**
| 장애 유형 | 원인 | 해결 방안 |
|----------|------|-----------|
| **서비스 장애** | 특정 마이크로서비스 다운 | 재시도(Retry) 로직, Circuit Breaker 패턴 적용 |
| **데이터 정합성 오류** | 중간 단계에서 트랜잭션 실패 | 보상 트랜잭션(Compensation Transaction) 실행 |
| **메시지 큐 지연** | Kafka, RabbitMQ 메시지 소비 지연 | 메시지 재처리 및 DLQ(Dead Letter Queue) 설정 |

✅ **각 서비스에 대한 장애 복구 로직을 사전에 설계해야 함**

---
## **6. 성능 모니터링 및 튜닝 전략**
### **📌 트랜잭션 성능 모니터링**
- **APM (Application Performance Monitoring) 도구 활용**
    - Prometheus + Grafana 대시보드 설정
    - Zipkin, Jaeger 등을 활용한 분산 트레이싱(Distributed Tracing)
- 
### **6. 비동기 처리 최적화**
#### ✅ **Kafka Consumer Lag 모니터링**
- **Consumer Lag**은 메시지 생산(Producer)과 소비(Consumer) 간의 지연을 나타내며, 지속적인 모니터링이 필요함.
- Prometheus + Grafana 대시보드를 활용하여 Kafka Consumer Lag을 시각화하고, 처리 속도를 최적화할 수 있음.

#### ✅ **멱등성 처리(Idempotency) 적용**
- 네트워크 장애 또는 중복 처리로 인해 같은 메시지가 여러 번 소비되는 문제 방지.
- **Idempotent Producer 설정** (`enable.idempotence=true`)을 적용하여 **중복 메시지 전송 방지**.
- **데이터베이스 레벨에서 unique constraint를 활용**하여 중복 삽입을 방지.
- **Redis 또는 Kafka의 Exactly-Once Semantics (EOS) 적용**을 고려.

✅ **성능 모니터링을 통해 트랜잭션 처리 지연을 최소화해야 함.**

---

## **7. 트랜잭션 전략 선택 가이드**
| **트랜잭션 방식** | **특징** | **적용 사례** |
|-----------------|----------|--------------|
| **SAGA 패턴** | 보상 트랜잭션을 통한 최종적 일관성 | **주문-결제-배송 서비스** |
| **2PC (Two-Phase Commit)** | 강한 데이터 일관성 | **은행 이체, 금융 서비스** |
| **이벤트 기반 트랜잭션** | 메시지 큐를 활용한 비동기 처리 | **로그 저장, 알림 서비스** |

✅ **MSA 환경에서는 성능과 확장성을 고려하여 SAGA 패턴을 가장 많이 사용하며, 경우에 따라 이벤트 기반 트랜잭션을 병행하는 것이 효과적이다.**

---

## **8. 결론**
- **MSA 환경에서는 단일 데이터베이스 기반의 ACID 트랜잭션을 유지하기 어렵다.**
- **SAGA 패턴이 가장 널리 사용되는 트랜잭션 관리 방식이며, 보상 트랜잭션을 통해 일관성을 유지할 수 있다.**
- **이벤트 기반 트랜잭션을 활용하면 강한 일관성이 필요하지 않은 경우에 유연한 확장성이 가능하다.**
- **2PC는 높은 데이터 일관성을 보장하지만, MSA 환경에서는 성능 저하와 복잡성 문제로 인해 권장되지 않는다.**

✅ **결론적으로, SAGA 패턴을 기반으로 하되, 필요에 따라 이벤트 기반 트랜잭션을 활용하는 것이 최적의 설계 방식이다.** 🚀

