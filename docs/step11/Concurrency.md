# 동시성 문제

** 동시성 문제(Concurrency Issues)**는 여러 작업(프로세스나 스레드)이 **공유 자원에 동시에 접근하거나 조작**할 때 발생하는 **의도하지 않은 결과**나 **데이터 손상**을 의미합니다.

## E - 커머스에서 발생할 수 있는 동시성 시나리오

- 사용자의 잔액을 충전하거나 사용할 대 동시성이 발생 할 수 있습니다.
     - 사용자가 충전 요청을2번할 경우 동시적 문제가 발생할 수 있다.
- 쿠폰발행 과정에서의 동시성 문제
    - 발행에 제한이 있는 쿠폰에 여러 사용자가 동시적으로 요청할 경우 동시적 문제가 발생 할 수 있다.
- 쿠폰을 사용할 때 동시성 문제
    - 쿠폰을 사용할 때 동일 쿠폰에 대해 요청을 2번할경우 동시적 문제가 발생 할 수 있다.
- 상품 재고 차감시에 동시성문제    
    - 다른 사용자가 같은 상품에 대해 구매할 경우 재고 차감 동시적 문제가 발생할 수 있다 


## DB의 동시성 문제와 제어 방법

### 트랜잭션(Transaction) 을 이용한 동시성 문제 제어 방식
  - 격리성(Isolation)은 트랜잭션 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장
 - 트랜잭션 격리 수준은 동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 격리되어 있는가를 나타내는 정도이다.
 - ANSI/ISO SQL 표준에서는 격리 수준을 READ_UNCOMMITED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE 4가지로 나누고 있다.

## ** 격리 수준의 종류**

| 격리 수준                | Dirty Read | Non-Repeatable Read | Phantom Read | 성능  |
|--------------------------|------------|---------------------|--------------|-------|
| **READ UNCOMMITTED**      | 허용        | 허용                 | 허용          | 매우 높음 |
| **READ COMMITTED**        | 방지        | 허용                 | 허용          | 높음  |
| **REPEATABLE READ**       | 방지        | 방지                 | 허용 (MySQL InnoDB에서는 방지) | 중간  |
| **SERIALIZABLE**          | 방지        | 방지                 | 방지          | 낮음  |

## **. 격리 수준 설명**

### **READ UNCOMMITTED**
- **Dirty Read 허용**: 커밋되지 않은 데이터를 읽을 수 있음.
- 성능은 가장 좋지만 데이터 일관성이 낮음.
- **적용 사례**:
  - 로그 데이터 수집, 데이터 정합성이 크게 중요하지 않은 경우.

---

### **READ COMMITTED**
- **Dirty Read 방지**: 커밋된 데이터만 읽을 수 있음.
- **Non-Repeatable Read 허용**: 동일 데이터를 반복 조회 시 값이 달라질 수 있음.
- 성능과 데이터 정합성의 균형이 적절.
- **적용 사례**:
  - 주문 상태 조회, 최신 데이터 조회.

---

### **REPEATABLE READ**
- **Dirty Read와 Non-Repeatable Read 방지**.
- MySQL InnoDB에서는 **Phantom Read도 방지**(갭 락 사용).
- MySQL InnoDB의 기본 격리 수준.
- **적용 사례**:
  - 재고 관리, 은행 계좌 이체 등 데이터 일관성이 중요한 경우.

---

### **SERIALIZABLE**
- **모든 동시성 문제 방지**: Dirty Read, Non-Repeatable Read, Phantom Read 모두 차단.
- 트랜잭션을 직렬로 실행하여 완벽한 데이터 정합성을 보장.
- 성능은 가장 낮음.
- **적용 사례**:
  - 선착순 쿠폰 발급, 대량 업데이트 등.

---
## ** 격리 수준에 따른 동시성 문제 제어**

| 격리 수준           | Dirty Read | Non-Repeatable Read | Phantom Read | 주요 동시성 문제 제어 |
|---------------------|------------|---------------------|--------------|-----------------------|
| **READ UNCOMMITTED** | O          | O                   | O            | 없음                  |
| **READ COMMITTED**   | X          | O                   | O            | Dirty Read 방지        |
| **REPEATABLE READ**  | X          | X                   | O (MySQL에서는 X) | Non-Repeatable Read 방지 |
| **SERIALIZABLE**     | X          | X                   | X            | 모든 동시성 문제 방지   |

## **. 정리 및 결론**

1. **격리 수준 선택 기준**:
   - **성능이 중요**: `READ COMMITTED`.
   - **일관성이 중요**: `REPEATABLE READ` 또는 `SERIALIZABLE`.

### Lock 을 이용한 동시성 문제 제어 방식    

- MySQL에서 Lock을 활용하면 트랜잭션이 동일한 데이터를 동시에 변경하는 것을 방지할 수 있습니다. **비관적 잠금(Pessimistic Lock)**과 **낙관적 잠금(Optimistic Lock)**을 활용하여 동시성 문제를 제어할 수 있습니다.

### 비관적 LOCK (Pessimistic Lock)
비관적 잠금은 자원에 대한 잠금을 먼저 얻고 작업을 수행하는 방식입니다. MySQL에서 FOR UPDATE와 LOCK IN SHARE MODE를 사용하여 트랜잭션이 작업을 수행하는 동안 다른 트랜잭션이 해당 데이터를 변경하지 못하도록 할 수 있습니다.

S-Lock (Shared Lock / LOCK IN SHARE MODE): 다른 트랜잭션이 읽을 수만 있고 수정할 수 없도록 잠금을 설정.
X-Lock (Exclusive Lock / FOR UPDATE ): 다른 트랜잭션이 읽고 수정할 수 없도록 잠금을 설정.

### 낙관적 잠금 (Optimistic Lock)
낙관적 잠금은 충돌이 드물다고 가정하고, 트랜잭션이 데이터를 수정하려고 할 때 충돌이 발생했는지를 확인하여 충돌이 있을 경우 재시도하는 방식입니다. JPA에서 @Version을 이용한 방식처럼 버전 관리를 통해 충돌을 감지합니다.

버전 필드 추가: 데이터베이스 테이블에 버전 번호를 추가하여 트랜잭션이 데이터를 수정할 때 버전 번호를 비교하고, 버전 충돌이 발생하면 OptimisticLockException을 발생시킵니다.    

-------
# 시나리오에서 사용한 Lock

## 잔액 사용 / 충전 (낙관적 락)
- 잔액 충전에서 낙관적 락을 사용한 이유(동시에 충전을 요청하는 충돌의 경우에 수가 적다고 생각했습니다.)
- ***중복요청 발생시 실패하는 케이스로 던져서 사용자에 한번더 충전요청을 받는 형태로 하는게 효율적이라 생각했습니다.***

한 사용자가 동시에 여러 번 충전 요청을 보낼 때, 각 요청이 동시에 같은 데이터를 수정하게 됩니다. 예를 들어, 1000원 충전 후 바로 또 500원 충전을 요청할 수 있습니다. 이때 두 충전이 동시에 처리되면, 각 요청이 **최초의 잔액(1000원)**을 기준으로 계산하여 중복된 업데이트가 발생할 수 있습니다.
낙관적 잠금은 버전 충돌을 통해 이런 문제를 처리할 수 있습니다.

| **특성**                    | **낙관적 잠금 (Optimistic Locking)**                  | **비관적 잠금 (Pessimistic Locking)**              |
|--------------------------|-----------------------------------------------|---------------------------------------------|
| **충돌 발생 시 처리**         | **예외 처리 및 재시도**                               | 충돌을 사전에 **방지**                           |
| **성능**                    | **충돌이 적으면 성능 우수**                               | **성능 저하** (자원 잠금으로 인한 대기 시간 증가)  |
| **병목 현상**                 | **없음** (잠금을 사용하지 않음)                           | **발생** (다른 트랜잭션이 자원을 기다림)            |
| **리소스 소모**               | **효율적** (리소스를 많이 사용하지 않음)                   | **많이 소모** (잠금을 유지하고 대기하는 동안 자원 사용)|
| **적합한 환경**               | **충돌이 적거나 드물게 발생하는 시스템**                      | **충돌을 완벽히 피하고자 하는 시스템**             |
| **데이터 처리 순서**          | **충돌 발생 시 처리할 수 있음**                           | **순차적 처리 보장**                             |


|# 분산락 (Distributed Lock) vs 비관적 잠금 (Pessimistic Lock)

## **기법 비교**

| **특징**                        | **분산락 (Distributed Lock)**                                       | **비관적 잠금 (Pessimistic Lock)**                              |
|--------------------------------|------------------------------------------------------------------|-------------------------------------------------------------|
| **기본 원리**                   | 락을 사용하여 여러 프로세스의 접근 제어                              | 미리 락을 설정하여 다른 프로세스 접근 차단                       |
| **사용 예**                     | 여러 서버에서 동일한 데이터베이스 항목 수정 시                           | 은행 계좌 이체와 같은 트랜잭션                                  |
| **장점**                        | 데이터 일관성과 무결성 보장                                         | 데이터 충돌 사전 방지                                           |
| **단점**                        | 락 설정 및 해제 시간 소요, 데드락 발생 가능성                         | 락이 오래 걸릴 수 있으며, 성능 저하 가능성                      |

## **상세 비교**

### **1. 기본 원리**
- **분산락**: 여러 서버나 애플리케이션 인스턴스가 동일한 리소스를 접근할 때, 레디스와 같은 **외부 키-값 저장소**를 사용하여 **락을 관리**합니다. **분산 시스템**에서 **자원에 대한 접근 제어**를 효율적으로 할 수 있습니다.
- **비관적 잠금**: 트랜잭션이 **동일 자원**을 수정하려 할 때, **잠금을 미리 설정**하여 다른 트랜잭션이 해당 자원에 접근하지 못하도록 하는 방식입니다.

### **2. 사용 예**
- **분산락**: 여러 서버가 동일한 리소스를 수정하는 상황에서, 예를 들어 **쿠폰 발급** 시스템이나 **재고 관리**와 같은 경우에 사용됩니다.
- **비관적 잠금**: **은행 계좌 이체**나 **주문 결제 시스템**과 같이 **동일 자원에 대한 동시 수정**을 방지해야 하는 경우에 사용됩니다.

### **3. 장점**
- **분산락**: 여러 서버가 동일 자원을 수정할 때 발생할 수 있는 **동시성 문제**를 해결할 수 있으며, **데이터 일관성**과 **무결성**을 보장합니다.
- **비관적 잠금**: **충돌을 사전에 방지**하고, **데이터 수정 중복**을 방지하여 데이터 **무결성**을 보장할 수 있습니다.

### **4. 단점**
- **분산락**: 락을 설정하고 해제하는 데 시간이 소요되며, **데드락**이 발생할 수 있습니다. 또한 **성능 저하**가 발생할 수 있습니다.
- **비관적 잠금**: **트랜잭션 대기**가 발생할 수 있으며, **성능 저하**가 발생할 수 있습니다. 특히, **동시성 요청이 많을 경우** 병목 현상이 발생할 수 있습니다.

## **결론**
- **분산락**은 **분산 시스템**에서 여러 서버가 동일 자원을 **수정**할 때 유용하며, **락을 중앙에서 관리**하므로 **동시성 문제**를 효과적으로 해결할 수 있습니다.
- **비관적 잠금**은 **동일 자원에 대한 수정**이 이루어지는 시스템에서 **충돌을 완벽히 방지**할 수 있지만, **성능 저하**가 발생할 수 있습니다. **동시성 트랜잭션이 많을 경우** **병목 현상**을 초래할 수 있습니다.
---- 
## 쿠폰 발급 (비관적 락)
- 쿠폰발급과 같은 시나리오에서는 비관적락을 사용한 이유는 헤당 자원에 접근할 때 먼저 자원을 잠궈 자원을 사용하는 동안에는 다른 트랜잭션이 접근하지 못하도록 충돌을 방지하기 위해 비관적락을 사용이 적합하다고 생각합니다. 추후에는 분산락을 사용할 수 있는 레디스를 활용하여 진행할 예정이며 선착순 순차적인걸 고려하여 카프카까지 적용하는것이 목표입니다.
** 아직 분산락까지 적용해서 하는것은 버겁다라고 생각하여 DBlock 까지만 진행했습니다 ** 

### 비관락을 쿠폰 발급 시스템에서 사용할 경우 야기될 수 있는 문제점

1. **성능 저하**:
   - 비관락은 트랜잭션이 완료될 때까지 데이터를 잠그는 방식입니다. 다수의 사용자가 동시에 쿠폰을 발급하려고 할 때, 대기 시간이 길어져 성능이 크게 저하될 수 있습니다.

2. **리소스 낭비**:
   - 락을 설정하고 유지하는 데 필요한 리소스가 많이 소모됩니다. 특히 사용자 수가 많은 경우, 시스템의 전체 성능을 저하시킬 수 있습니다.

3. **확장성 문제**:
   - 쿠폰 발급 시스템은 보통 많은 사용자들이 동시에 접근하는 경우가 많습니다. 비관락은 이러한 환경에서 확장성을 제한할 수 있습니다.

4. **데드락 발생 가능성**:
   - 여러 트랜잭션이 서로의 락을 기다리면서 데드락 상황이 발생할 수 있습니다. 이는 시스템을 정지시키거나 성능 문제를 유발할 수 있습니다.

## 재고감소 (비관적 락)

- 상품의 재고관리에서 비관적 락을 사용한 이유는 아무래도 성능적인 측면보다는 데이터의 정합성을 위해서 동시에 접근할 때 미리 재고에 대한 락을 설정하는게 정합성 측면에서 더 유리하다고 생각하여 재고 관리에 비관적 락을 사용했습니다.


